-- ==========================================
-- Database Refactor Migration V2
-- Goal: Standardize naming, normalize data, enhance metadata
-- ==========================================

-- 1. Rename "Franchises" to "franchises" and standardizing columns
-- ==========================================

-- Rename table if it exists with the old quoted name
DO $$
BEGIN
    IF EXISTS (SELECT FROM pg_tables WHERE tablename = 'Franchises') THEN
        ALTER TABLE "Franchises" RENAME TO franchises;
    END IF;
END
$$;

-- Add new metadata columns
ALTER TABLE franchises 
    ADD COLUMN IF NOT EXISTS source_url TEXT,
    ADD COLUMN IF NOT EXISTS last_scraped_at TIMESTAMPTZ,
    ADD COLUMN IF NOT EXISTS slug TEXT,
    ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT TRUE;

-- Create index on slug
CREATE INDEX IF NOT EXISTS idx_franchises_slug ON franchises(slug);


-- 2. Normalize Categories
-- ==========================================

-- Create categories table
CREATE TABLE IF NOT EXISTS categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    slug TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create join table
CREATE TABLE IF NOT EXISTS franchise_categories (
    franchise_id BIGINT REFERENCES franchises(id) ON DELETE CASCADE,
    category_id BIGINT REFERENCES categories(id) ON DELETE CASCADE,
    PRIMARY KEY (franchise_id, category_id)
);

-- Migrate existing JSONB sub_categories to new tables
-- Handles both JSON arrays ["Food", "Retail"] and simple strings "Food"
DO $$
DECLARE
    f record;
    cat_name text;
    new_cat_id bigint;
BEGIN
    -- Iterate through franchises that have sub_categories
    FOR f IN SELECT id, sub_categories FROM franchises WHERE sub_categories IS NOT NULL LOOP
        
        -- If it is an array, iterate elements
        IF jsonb_typeof(f.sub_categories) = 'array' THEN
            FOR cat_name IN SELECT jsonb_array_elements_text(f.sub_categories) LOOP
                IF cat_name IS NOT NULL AND cat_name != '' THEN
                    -- Insert category
                    INSERT INTO categories (name, slug)
                    VALUES (cat_name, lower(regexp_replace(cat_name, '[^a-zA-Z0-9]+', '-', 'g')))
                    ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
                    RETURNING id INTO new_cat_id;
                    
                    -- Link
                    INSERT INTO franchise_categories (franchise_id, category_id)
                    VALUES (f.id, new_cat_id)
                    ON CONFLICT DO NOTHING;
                END IF;
            END LOOP;
            
        -- If it is a simple string (scalar), treat as single category
        ELSIF jsonb_typeof(f.sub_categories) = 'string' THEN
            cat_name := f.sub_categories #>> '{}';
            IF cat_name IS NOT NULL AND cat_name != '' THEN
                INSERT INTO categories (name, slug)
                VALUES (cat_name, lower(regexp_replace(cat_name, '[^a-zA-Z0-9]+', '-', 'g')))
                ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
                RETURNING id INTO new_cat_id;
                
                INSERT INTO franchise_categories (franchise_id, category_id)
                VALUES (f.id, new_cat_id)
                ON CONFLICT DO NOTHING;
            END IF;
        END IF;
        
    END LOOP;
END
$$;


-- 3. Normalize Lead Matches
-- ==========================================

CREATE TABLE IF NOT EXISTS lead_matches (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    lead_id BIGINT REFERENCES leads(id) ON DELETE CASCADE,
    franchise_id BIGINT REFERENCES franchises(id) ON DELETE CASCADE,
    match_score FLOAT,
    match_reason TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(lead_id, franchise_id)
);

-- Index for fast lookup of "My Matches"
CREATE INDEX IF NOT EXISTS idx_lead_matches_lead_id ON lead_matches(lead_id);


-- 4. Update Functions
-- ==========================================

-- Drop old functions with old signatures/dependencies
DROP FUNCTION IF EXISTS match_franchises_hybrid(vector, float, int, int);
DROP FUNCTION IF EXISTS match_franchises_hybrid(vector, float, int, int, text);
DROP FUNCTION IF EXISTS get_franchises_by_state(text);

-- Recreate match_franchises_hybrid with new table name and structure
create or replace function match_franchises_hybrid (
  query_embedding vector(1536),
  match_threshold float,
  match_count int default 10,
  max_budget int default null,
  location_filter text default null
)
returns table (
  id bigint,
  franchise_name text,
  primary_category text,
  sub_categories jsonb, -- Kept for backward compatibility, but populated from relations could be better in future
  description_text text,
  total_investment_min_usd int,
  similarity float,
  unavailable_states jsonb,
  slug text
)
language plpgsql
as $$
begin
  return query (
    select
      f.id,
      f.franchise_name,
      f.primary_category,
      f.sub_categories, -- Returning the original JSONB for now to avoid frontend break
      f.description_text,
      f.total_investment_min_usd,
      1 - (f.franchise_embedding <=> query_embedding) as similarity,
      f.unavailable_states,
      f.slug
    from
      franchises f
    where
      f.is_active = true
      -- 1. Similarity Threshold
      and 1 - (f.franchise_embedding <=> query_embedding) > match_threshold
      
      -- 2. Budget Filter
      and (max_budget is null or f.total_investment_min_usd <= max_budget)
      
      -- 3. Location Filter
      and (
        location_filter is null 
        or (
          -- Rule A: Territory Check
          not exists (
            select 1 from territory_checks tc 
            where tc.franchise_id = f.id 
            and tc.state_code = location_filter 
            and tc.availability_status = 'Not Available'
          )
          -- Rule B: Static Unavailable List
          and (
             f.unavailable_states is null 
             or not (f.unavailable_states::jsonb ? location_filter)
          )
        )
      )
    order by
      f.franchise_embedding <=> query_embedding
    limit
      match_count
  );
end;
$$;


-- Recreate get_franchises_by_state
create or replace function get_franchises_by_state (
  filter_state_code text
)
returns table (
  id bigint,
  franchise_name text,
  primary_category text,
  sub_categories jsonb,
  description_text text,
  total_investment_min_usd int,
  image_url text,
  slug text
)
language plpgsql
as $$
begin
  return query (
    select
      f.id,
      f.franchise_name,
      f.primary_category,
      f.sub_categories,
      f.description_text,
      f.total_investment_min_usd,
      null::text as image_url,
      f.slug
    from
      franchises f
    where
      f.is_active = true
      and (
         f.unavailable_states is null 
         or not (f.unavailable_states::jsonb ? filter_state_code)
      )
      and not exists (
        select 1 from territory_checks tc 
        where tc.franchise_id = f.id 
        and tc.state_code = filter_state_code 
        and tc.availability_status = 'Not Available'
      )
    order by
      f.franchise_name asc
  );
end;
$$;

